// A look at what this might be in sql or relational syntax
//groups: {groupno:, member:, question:}

templates groupAsRelations
  @: {groupno: 1, member: 1};
  $... -> #
  $@!
  when <=''> do @: {groupno: $@.groupno + 1, member: 1};
  otherwise
    $... -> {groupno: $@.groupno, member: $@.member, question: $}!
    @.member: $@.member + 1;
end groupAsRelations

def groups: {[[$IN::lines] -> groupAsRelations]};

//part 1 sql
//select sum(qpergroup) from (select count(distinct(question)) from groups as qpergroup group by groupno)

// relational algebra
//groups.project(groupno:, question:).group([question:], questions:).extend(qpergroup:, lambda t: t.questions.count())
//  .sum(lambda t: t.qpergroup)

// part 2 sql
//select sum(qpergroup) from
//(select groupno, count(distinct(question)) from
//(select groupno, question from groups as r
//  where not exists (select member from groups as s
//    where s.groupno = r.groupno
//    and not exists (select question from groups as r2
//      where r2.groupno = r.groupno
//      and r2.member = s.member
//      and r2.question = r.question))
//) group by groupno)

// relational
//def s: groups.project(groupno:, member:).group([member:], members:);
//def r: groups.group([member:, question:], questions:);
//(r & s).extend(qforall:, lambda t: (t.questions div t.members).count()).sum(qforall:)

//tailspin
def groups: $input({{groupno:, member:, question:}});
$groups({groupno:, members: {{member:}}, answers: {{member:, question:}}})
  -> $({groupno:, answeredbyall: ((answers:) div (members:)) -> $::count})
  -> $([(answeredbyall:)]) -> sum
